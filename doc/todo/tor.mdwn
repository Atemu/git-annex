git-annex sync over tor

Mostly working!

Current todo list:

* copy --to peer of a 100 mb file causes the memory of the remotedaemon
  to creep up from 40 mb to 136 mb. Once the transfer is done, the
  remotedaemon continues using all that memory. Memory leak. Profile it.  
  (The sending process creeps up some initially, but stops at 45 mb used.
  That could just be buffering.)  
  (copy --from peer does not leak on either end; the remotedaemon uses 34
  mb and the receiver 44 mb.)

  Profiling results: Leak is in hGetMetered, or perhaps in
  the consumer of the data it reads. Graph shows `ARR_WORDS` is
  the type; that must be a bytestring.

<pre>                                                                                                                   individual      inherited
COST CENTRE                                               MODULE                               no.      entries  %time %alloc   %time %alloc
                     tryNonAsync                          Utility.Exception                    3241          0    0.0    0.1    49.3   65.8
                      receiveExactly                      P2P.IO                               3429          0    0.0    0.0    49.3   65.7
                       hGetMetered                        Utility.Metered                      3430          0   49.1   65.6    49.3   65.7
</pre>

  Switching to L.hGet, it still leaks, so seems hGetMetered is not at fault
  and the bytestring is being buffered excessively somehow before it
  reaches the file.

  Aha! While a send is in progress like this, .git/annex/tmp is empty!
  The whole file is being buffered in memory and written at the end.

* When a transfer can't be done because another transfer of the same 
  object is already in progress, the message about this is output by the
  remotedaemon --debug, but not forwarded to the peer, which shows
  "Connection reset by peer"
* update progress logs in remotedaemon send/receive
* Think about locking some more. What happens if the connection to the peer
  is dropped while we think we're locking content there from being dropped?

Eventually:

* Limiting authtokens to read-only access.
* Revoking authtokens. (This and read-only need a name associated with an
  authtoken, so the user can adjust its configuration after creating it.)
* address exchange via electrum-mnemonic or magic wormhole (see PAKE)
* webapp UI for easy pairing
* friend-of-a-friend peer discovery to build more interconnected networks
  of nodes
