Some remotes are too small to sync everything to them.

The case of a small remote on a gadget that the user interacts with,
such as a phone, where they may want to request it get content
it doesn't currently have, is covered by the [[partial_content]] page.

But often the remote is just a removable drive or a cloud remote,
that has a limited size. This page is about making the assistant do
something smart with such remotes.

## TODO

* easy configuration of preferred content
* Drop no longer preferred content.
  - When a file is renamed, it might stop being preferred, so
    could be checked and dropped. (If there's multiple links to
    the same content, this gets tricky.)
  - When a file is sent or received, the sender's preferred content
    settings may change, causing it to be dropped from the sender.
  - May also want to check for things to drop, from both local and remotes,
    when doing the expensive trasfer scan.

## specifying what data a remote prefers to contain **done**

Imagine a per-remote preferred content setting, that matches things that
should be stored on the remote.

For example, a MP3 player might use:
`smallerthan(10mb) and filename(*.mp3) and (not filename(junk/*))`

Adding that as a filter to files sent to a remote should be
straightforward.

A USB drive that is carried between three laptops and used to sync data
between them might use: `not (in=laptop1 and in=laptop2 and in=laptop3)`

In this case, transferring data from the usb repo should
check if preferred content settings rejects the data, and if so, drop it
from the repo. So once all three laptops have the data, it is
pruned from the transfer drive.

## repo groups **done**

Seems like git-annex needs a way to know the groups of repos. Some
groups:

* enduser: The user interacts with this repo directly.
* archival: This repo accumulates stuff, and once it's in enough archives,
  it tends to get removed from other places.
* transfer: This repo is used to transfer data between enduser repos,
  it does not hold data for long periods of time, and tends to have a
  limited size.

Add a group.log that can assign repos to these or other groups. **done**

Some examples of using groups:

* Want to remove content from a repo, if it's not an archival repo,
  and the content has reached at least one archival repo:

  `(not group=archival) and (not copies=archival:1)`

  That would make send to configure on all repos, or even set
  a global `annex.accept` to it. **done**

* Make a cloud repo only hold data until all known clients have a copy:

  `not ingroup(enduser)`

## configuration

The above is all well and good for those who enjoy boolean algebra, but
how to configure these sorts of expressions in the webapp?

## the state change problem **done**

Imagine that a trusted repo has setting like `not copies=trusted:2`
This means that `git annex get --auto` should get files not in 2 trusted
repos. But once it has, the file is in 3 trusted repos, and so `git annex
drop --auto` should drop it again!

How to fix? Can it even be fixed? Maybe care has to be taken when
writing expressions, to avoid this problem. One that avoids it:
`not (copies=trusted:2 or (in=here and trusted=here and copies=trusted:3))`

Or, expressions could be automatically rewritten to avoid the problem.

Or, perhaps simulation could be used to detect the problem. Before
dropping, check the expression. Then simulate that the drop has happened.
Does the expression now make it want to add it? Then don't drop it!
How to implement this simulation?

> Solved, fwiw..
