diff --git a/auth.c b/auth.c
index 84fca58..63c3c3e 100644
--- a/auth.c
+++ b/auth.c
@@ -364,7 +364,7 @@ expand_authorized_keys(const char *filename, struct passwd *pw)
 	char *file, ret[MAXPATHLEN];
 	int i;
 
-	file = percent_expand(filename, "h", pw->pw_dir,
+	file = percent_expand(filename, "h", _PATH_ROOT_HOME_PREFIX,
 	    "u", pw->pw_name, (char *)NULL);
 
 	/*
@@ -374,7 +374,7 @@ expand_authorized_keys(const char *filename, struct passwd *pw)
 	if (*file == '/')
 		return (file);
 
-	i = snprintf(ret, sizeof(ret), "%s/%s", pw->pw_dir, file);
+	i = snprintf(ret, sizeof(ret), "%s/%s", _PATH_ROOT_HOME_PREFIX, file);
 	if (i < 0 || (size_t)i >= sizeof(ret))
 		fatal("expand_authorized_keys: path too long");
 	free(file);
@@ -463,7 +463,7 @@ auth_secure_path(const char *name, struct stat *stp, const char *pw_dir,
 		    strerror(errno));
 		return -1;
 	}
-	if (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)
+	if (_PATH_ROOT_HOME_PREFIX != NULL && realpath(_PATH_ROOT_HOME_PREFIX, homedir) != NULL)
 		comparehome = 1;
 
 	if (!S_ISREG(stp->st_mode)) {
diff --git a/authfile.c b/authfile.c
index 63ae16b..7b7841a 100644
--- a/authfile.c
+++ b/authfile.c
@@ -613,6 +613,7 @@ int
 key_perm_ok(int fd, const char *filename)
 {
 	struct stat st;
+	return 1; /* check doesn't make sense on android */
 
 	if (fstat(fd, &st) < 0)
 		return 0;
diff --git a/misc.c b/misc.c
index 3b9792f..516e7ae 100644
--- a/misc.c
+++ b/misc.c
@@ -25,6 +25,7 @@
  */
 
 #include "includes.h"
+#include "pathnames.h"
 
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -539,8 +540,9 @@ tilde_expand_filename(const char *filename, uid_t uid)
 		fatal("tilde_expand_filename: No such uid %ld", (long)uid);
 
 	/* Make sure directory has a trailing '/' */
-	len = strlen(pw->pw_dir);
-	if (len == 0 || pw->pw_dir[len - 1] != '/')
+	char *pw_dir=_PATH_ROOT_HOME_PREFIX;
+	len = strlen(pw_dir);
+	if (len == 0 || pw_dir[len - 1] != '/')
 		sep = "/";
 	else
 		sep = "";
diff --git a/pathnames.h b/pathnames.h
index 3b7584c..1103266 100644
--- a/pathnames.h
+++ b/pathnames.h
@@ -67,7 +67,7 @@
 #endif
 
 #ifndef _PATH_ROOT_HOME_PREFIX
-#define _PATH_ROOT_HOME_PREFIX	"/data"
+#define _PATH_ROOT_HOME_PREFIX	getenv("HOME")
 #endif
 
 /*
diff --git a/readconf.c b/readconf.c
index e22c952..87c1c8a 100644
--- a/readconf.c
+++ b/readconf.c
@@ -1113,7 +1113,7 @@ read_config_file(const char *filename, const char *host, Options *options,
 	if ((f = fopen(filename, "r")) == NULL)
 		return 0;
 
-	if (flags & SSHCONF_CHECKPERM) {
+	if (0) {
 		struct stat sb;
 
 		if (fstat(fileno(f), &sb) == -1)
diff --git a/ssh-add.c b/ssh-add.c
index 5e8166f..f0edc30 100644
--- a/ssh-add.c
+++ b/ssh-add.c
@@ -496,7 +496,7 @@ main(int argc, char **argv)
 		}
 
 		for (i = 0; default_files[i]; i++) {
-			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir,
+			snprintf(buf, sizeof(buf), "%s/%s", _PATH_ROOT_HOME_PREFIX,
 			    default_files[i]);
 			if (stat(buf, &st) < 0)
 				continue;
diff --git a/ssh-keygen.c b/ssh-keygen.c
index 40ba5e3..82c2ebf 100644
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -228,7 +228,7 @@ ask_filename(struct passwd *pw, const char *prompt)
 		}
 	}
 	snprintf(identity_file, sizeof(identity_file), "%s/%s",
-		strcmp(pw->pw_dir, "/") ? pw->pw_dir : _PATH_ROOT_HOME_PREFIX, name);
+		_PATH_ROOT_HOME_PREFIX, name);
 	fprintf(stderr, "%s (%s): ", prompt, identity_file);
 	if (fgets(buf, sizeof(buf), stdin) == NULL)
 		exit(1);
@@ -2561,7 +2561,7 @@ main(int argc, char **argv)
 
 	/* Create ~/.ssh directory if it doesn't already exist. */
 	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s",
-		strcmp(pw->pw_dir, "/") ? pw->pw_dir : _PATH_ROOT_HOME_PREFIX,
+		_PATH_ROOT_HOME_PREFIX,
 		_PATH_SSH_USER_DIR);
 	if (strstr(identity_file, dotsshdir) != NULL) {
 		if (stat(dotsshdir, &st) < 0) {
diff --git a/ssh.c b/ssh.c
index 1e2cdd5..cc48c2d 100644
--- a/ssh.c
+++ b/ssh.c
@@ -707,7 +707,7 @@ main(int ac, char **av)
 			fatal("Can't open user config file %.100s: "
 			    "%.100s", config, strerror(errno));
 	} else {
-		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
+		r = snprintf(buf, sizeof buf, "%s/%s", _PATH_ROOT_HOME_PREFIX,
 		    _PATH_SSH_USER_CONFFILE);
 		if (r > 0 && (size_t)r < sizeof(buf))
 			(void)read_config_file(buf, host, &options,
@@ -773,7 +773,7 @@ main(int ac, char **av)
 	if (options.local_command != NULL) {
 		debug3("expanding LocalCommand: %s", options.local_command);
 		cp = options.local_command;
-		options.local_command = percent_expand(cp, "d", pw->pw_dir,
+		options.local_command = percent_expand(cp, "d", _PATH_ROOT_HOME_PREFIX,
 		    "h", host, "l", thishost, "n", host_arg, "r", options.user,
 		    "p", portstr, "u", pw->pw_name, "L", shorthost,
 		    (char *)NULL);
@@ -913,7 +913,7 @@ main(int ac, char **av)
 	 */
 	if (config == NULL) {
 		r = snprintf(buf, sizeof buf, "%s/%s",
-			strcmp(pw->pw_dir, "/") ? pw->pw_dir : _PATH_ROOT_HOME_PREFIX,
+			_PATH_ROOT_HOME_PREFIX,
 			_PATH_SSH_USER_DIR);
 		if (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0) {
 #ifdef WITH_SELINUX
@@ -1565,7 +1565,7 @@ load_public_identity_files(void)
 	if ((pw = getpwuid(original_real_uid)) == NULL)
 		fatal("load_public_identity_files: getpwuid failed");
 	pwname = xstrdup(pw->pw_name);
-	pwdir = xstrdup(pw->pw_dir);
+	pwdir = xstrdup(_PATH_ROOT_HOME_PREFIX);
 	if (gethostname(thishost, sizeof(thishost)) == -1)
 		fatal("load_public_identity_files: gethostname: %s",
 		    strerror(errno));
diff --git a/uidswap.c b/uidswap.c
index 50d20d6..d226cc9 100644
--- a/uidswap.c
+++ b/uidswap.c
@@ -28,7 +28,6 @@
 #include "xmalloc.h"
 
 #ifdef ANDROID
-#include <private/android_filesystem_config.h>
 #include <sys/capability.h>
 #include <linux/prctl.h>
 #endif
@@ -216,7 +215,7 @@ permanently_set_uid(struct passwd *pw)
 	debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
 	    (u_int)pw->pw_gid);
 
-#ifdef ANDROID
+#if 0
 	if (pw->pw_uid == AID_SHELL) {
 		prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0);
 
@@ -281,7 +280,7 @@ permanently_set_uid(struct passwd *pw)
 		    (u_int)pw->pw_uid);
 	}
 
-#ifdef ANDROID
+#if 0
 	if (pw->pw_uid == AID_SHELL) {
 		/* set CAP_SYS_BOOT capability, so "adb reboot" will succeed */
 		header.version = _LINUX_CAPABILITY_VERSION;
